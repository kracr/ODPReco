To represent that some agent is acting in order to forward the action of a social (non-physical) agent
This pattern represents a flexible schema for linked data querying of chess games. Players are modeled as AgentRole. In addition, notions such as chess moves, chess tournaments, as well as chess game annotation are included.
The intent of the pattern is to be able to represent climatic zones for aquatic resources.This pattern only allows to query what climatic zones are typical of an aquatic resource. Whereas such values can be subject to observation, another pattern based on the generic 'observation' pattern should be used.The climatic zone is intended to have a fixed set of values (to be defined as nominals) but this is not explicit in the pattern.
To formally represent a conceptualization or a descriptive context.This CP allows the designer to represent both a (descriptive) context and the elements that characterize and are involved in that context.
The hazardous situation ontology design pattern provides a building block for modelling situations where one or more objects is exposed to one or more hazards to some extent (exposure value). Such situations have some cause that triggered enactment of a hazard. They also result in some consequences.
This pattern is a basic one, which allows to talk about attributes/parameters/dimensions, while still referring to their values. It creates a path from things to data values through 'regions' representing attributes.
The Afforndance ODP relies on the descriptions and situations ODP, and is combined with a frame-based representation scheme. This allows to extend the notion of affordance not only to physical objects, but also complex situations afford actions.
To incorporate the general two perspectives of activities: a workflow perspective, which are often observed in planning-related applications, and a spatiotemporal perspective, which are often found in geographic activity analysis.
The pattern intends to model the domain of born digital archives. The design pattern is expected to facilitate the creation of domain ontologies related to Born Digital Archives that can be exploited in numerous fields. A well-established, comprehensible pattern will prove to be advantageous.
To represent the relations between concepts (roles, task, parameters) and entities (person, events, values), which concepts can be assigned to. To formalize the application (e.g. tagging) of informal knowledge organization systems such as lexica, thesauri, subject directories, folksonomies, etc., where concepts are first-order elements.
To represent (non-transitively) that objects either are proper parts of other objects, or have proper parts.This Content OP allows designers to represent part-whole relations. It allows to distinguish between parts and proper parts. Relation of proper part is not transitive, and implies a simple part of relation, which is transitive. Temporal indexing is not expressible. To solve this issue see the time indexed part of Content OP.
The pattern intends to model computer systems based on a hardware/software approach. This pattern has been developed by MKLab at CERTH/ITI and Tate for the PERICLES FP7 project.The design pattern is expected to facilitate the creation of computer system domain ontologies that can be exploited in numerous fields. A well-established, comprehensible pattern will prove to be advantageous.Scenarios:	The computer uses Ubuntu 16.04.The graphics card requires driver A.The software is compatible with Windows 10.The processor is compatible with motherboard B
To represent the constituents of a layered structure. A desirable advantage of this CP is that we are able to talk e.g. of physical constituents ofnon-physical objects (e.g. systems), while this is typically impossible in terms of parts. This Content OP has to be distinguished from part of, collection entity, and componency Content OPs.
The pattern intends to model digital video files, their components and other associated entities, such as codecs and containers.The design pattern is expected to facilitate the creation of digital video domain ontologies that will be exploited in the field of digital preservation. A well-established, comprehensible pattern will prove to be advantageous.
The purpose of this pattern is to provide a minimalistic model of event where it is not always possible to separate its spatial and the temporal aspects, thus can model events that move or possess discontinuous temporal extent. Events according to this model has at least one participant, attached via a participant-role, and may have additional descriptive information through its information object.
It allows to categorize gene-related types into three main types.It allows to represent parts of gene-related entities (transitively). It does not allow to represent the relationships between entities of different types. It does not say anything about disjointness of categories.
The pattern outlines the relations between aquatic species and types of fishing gear that are suitable for catching exemplars thereof. While we do not make this distinction from the species' viewpoint, we do distinguish what species are gear types targeted to and what can be also incidentally caught. Since the original model does not hint at any other possible use for the three object properties presented herein, restriction superclasses for domains and ranges have been refactored as domain and range axioms for said properties. Note that this pattern can also be combined with :gearvessel.owl for answering what species can be caught using what vessel types. This can be inferred transitively.
To represent information objects and their physical realization.This pattern allows to distinguish information objects from their concrete realizations.
To represent the meaning of an information object: the concepts it expresses, the things it is about.This pattern employs a simple set of properties to link information objects to their meanings, and to entities they can be about
Heterogeneous models for invoices can be aligned to this pattern, which then acts as a semantic facade to different invoice management applications. The Context class can be used to gather temporal,spatial and organizational data. Otherwise, other specific patterns can be composed in order to deal with that.
Life Cycle Assessment (LCA) studies the environmental impact of products taking into account their entire life-span and production chain. This ontology design pattern specifies key aspects of LCA/LCI data models, namely the notions of flows, activities, agents, and products, as well as their properties.
Representing ordered lists, through a specialization of the bag pattern, where each resource in the bag is referred through an item, so that the same item can occur in several places. The usual properties of lists are also there, i.e. the sequence of elements, and references to the first and last item.
To represent events with their participants, time, space, etc.All sorts of relations denoting events with multiple participants, space-time indexing, etc. can be represented with this pattern. When objects participate at the event at different times or with different parts, more elementary nary-participation instances must be created, and made parts of the main one
The pattern can be used for modelling situations in which we are not certain that a particular actual event has the properties which were described in a news message. We want to define the properties of an actual event which were reported (time, place, actors, subevents, cause, effect etc.), but not to treat them as universal, verified knowledge. The pattern also allows to define who is responsible for a particular
To represents objects and the roles they play.
To talk about places of things.We can represent, transitively, where something is located. It remains unspecified what kind of location relation we are trying to represent: reference location, partial location, physical location, social or metaphoric location, etc.
The pattern intends to model policies, their characteristics and their associated entities, such as processes and agents. 
To model dynamic situations, tracking agents and actions they produce, events that are results of some action(s), and consequences as new actions, i.e. reactions
To represent the assignment of tasks to roles.his pattern allows to put roles in the domain of discourse. It does not allow to model time indexed task assignement.
A Set is a collection that cannot contain duplicate elements. A Set is expressed by linking to it directly all the members (elements), multiple identical values of members (elements) will be eliminated because by default they are treated as a set.
The goal of this pattern is to represent objects that can be simple or aggregated (that is, several objects gathered in another object acting as a whole).The main difference between the aggregation relation and other mereological relationships (such as part-of or componency) is that the aggregated object and its aggregated members should belong to the same concept. For example, a turbine is part of an engine, whereas an aggregated provider is formed by providers.
to represent species together with their typical environment in terms of bathymetric range and water area.The pattern allows to represent species with a typical bathymetric range and a typical water area where the exemplars (from an AquaticResource) can be found. However, there is no direct relation between the bathymetric range and the water area; in principle, it is possible that there are no places in the water area that provide the conditions for that bathymetric range.
To represent a tagging situation, in which someone uses a term, from a list of a folksonomy, to tag something (or the content of something). We might also want to represent the time and the polarity of the tagging.
To represent actions through which tasks are executed.This CP allows designers to make assertions on roles played by agents without involving the agents that play that roles, and vice versa. It allows to express neither the context type in which tasks are defined, not the particular context in which the action is carried out. Moreover, it does not allow to express the time at which the task is executed through the action (for actions that do not solely execute that certain task).	
To represent participants in events at some time,To represent participants in parts of events.
To represent topics and their relations.Topics are modelled as conceptual complexes with part of (containment), overlap, and vicinity relations, and can be related to any kind of entity. They are disjoint from "Concepts", which can be at the "core" of topics
To represent basic knowledge about transitions (events, states, processes, objects).
The intent of the pattern is to be able to represent vertical distribution for aquatic resources.This pattern only allows to query what vertical distribution is typical of an aquatic resource. Whereas such values can be subject to observation, another pattern based on the generic 'observation' pattern should be used.The vertical distribution is intended to have a fixed set of values (to be defined as nominals) but this is not explicit in the pattern.
to provide a direct relation between aquatic species and vessels that are able to catch them, regardless of the fishing gear used
The pattern provides a model of trajectory, which is understood as a sequence of spatiotemporal points. The model generalizing the Semantic Trajectory pattern from [Hu, et al., COSIT 2013] by employing the notion of place, instead of location/geo-coordinate, to represent the spatial extent of the trajectory. This pattern is suitable for a variety of trajectory datasets and easily extendible by by aligning to or matching with existing trajectory ontologies, foundational ontologies, or other domain specific vocabularies.
To the author's knowledge, there is limited work to the knowledge description in today's telecommunication networks, let alone the knowledge pattern. We observed and summarised an repeating pattern during the ontology construction process for the telecommunication networks.
To model different interactions where the interactors can have different roles.
To model a sequence of events, one after the other.
The List is used to model ordered elements, representing the semantics of the order: in this case the ODP will be used to build a gene starting from some elements of the Sequence Ontology
To model selective transitive propagation.In the biomedical domain the propagation of properties along the partonomy relation is very important. For example, there are cases where the fault of the part should be assumed to be a fault of the whole (an appendix perforation is an intestine perforation) and other cases where it should not be considered like that (appendicitis is not enteritis).
to model exceptions without breaking the strict class-subclass hierarchy: for example the class MammalianRedBloodCell (with the restriction HasNucleus exactly 0) would be a subclass of EukaryoticCell (with the restriction HasNucleus exactly 1), resulting in an inconsistent ontology. There can be exceptions to the exception in the next level: avian red blood cells do posses a nucleus, thus, they are considered normal eukaryotic cells (they are an exception to the norm that all red blood cells lack a nucleus). So the problem that this ODP solves can rise in different levels.
To represent a datatype value with more than one aspect. Numerical values can have different aspects. For example, a boiling point has a temperature value, a pressure, etc. This simple ODP should be used to model those cases.
To model features with the simplest structure possible.This ODP is used to represent modifiers with multiple aspects, thus features (e.g. colour with a certain brightness and saturation).
To recreate selectors, that is refining entities that can be used to choose between to alternatives: for example, right or left hand. Selectors are widely used in the biomedical domain, especially in the realm of anatomy. A selector is a modifier that can be used to select between identical entities, e.g. right and left hand. Selectors are usually associated with simmetry (left-right,anterior-posterior,lateral-medial) and sometimes hard coded in ontologies, that is, for example left hand and right hand are introduced as subclasses of hand, which adds an unecessary amount of classes. This ODP avoids such proliferation of classes.
To untangle a polyhierarchy, coding the subsumption relationships using restrictions rather than class-subclass relationships. The application example for this ODP is adapted from the Cell Type Ontology. In the example, the subsumption relationships that already are in the Cell Type Ontology are inferred by the reasoner instead of hard-coded. The term Neutrophil is used as an example class to show how a class can relate to different modules.
To create an ontology that can integrate different ontologies in itself.
Simulate the closed world assumption in a concrete class.OWL sometimes is anti-intuitive due to the Open World Assumption. One of the examples of such problem is the fact that plenty of users think that asserting an existential restriction is enough to close a relationship, when in fact a universal restriction is also needed: it is not enough to say that carnivore eats some meat, as that is equivalent to saying that it can eat another things apart of meat.
To model qualities without relying in a proliferation of object properties, as in the Entity-Property-Quality ODP.
To model values of attributes. In this example we model biological regulation, being negative or positive. PositiveRegulationOfCellKilling, from GO, is linked to the appropriate value.
To model qualities of independent entities (e.g. position, colour, ...).
To simulate an If-Then of the type: if something fullfills certain conditions, it should have a further given attribute.
Very unlikely that an Agent will be associated with something for all time. Thus, the association relationis not binary, perhaps associated(x, y, t), agent x is associated with thing y at time t. Thus, the reification. The association becomes a concept in its own right and has a temporal extent, allowing an Agent to be associated to a Thing 
The pattern for an Aggregation, Bag, or Collection is relatively simple. The Bag is a type of unorderedcollection. This pattern was included in this library for demonstrating a more approachableinterface for the partonymy pattern, with respect to membership. For example, we may use this pattern to represent a committee. In this case, the committee member is theBagItem, the committee is the Bag, and the itemOf property is a sub-property to the po-member propertyfound in the Partonymy/Meronymy pattern 
The purpose of this pattern is to provide a minimalistic model of an event where it is not always possible to separate its spatial and the temporal aspects, thus can model events that move or possess discontinuous tporal extent. Events, according to this model, have at least one participant, attached via a ParticipantRole 
The pattern for explicit typing is very straightforward. Indeed, it is merely a representation of what we consider to be a "best practice." This pattern is used when there is a finite, but mutable number of types of a thing. We find this easier to maintain than a series of subclass relationships. 
This pattern is used for associating some sort of identifier and metadata with a thing. One could view this pattern as a reification of the ExplicitType Pattern as found in Section 3.1. In this case, we wish to associate additional information aside from its type with a thing, e.g. an identifier may be a URL or a primary key value in a database. We believe that this pattern meshes well with the EntityWithProvenance Pattern
The NameStub Pattern is a specialization of the Stub Pattern found in Section 3.3. It is included here for convenience as it is has been frequently encountered in our modelling experiences.
 The ParticipantRole Pattern is a specialization of the AgentRole Pattern, which can be found in Section 3.12; many axioms are inherited due to this. We include it for convenience as it occurs frequently in our modelling experiences. This pattern has additional synergies with the Event
The EntityWithProvenance Pattern is extracted from the PROV-O ontology. At the pattern level, we do not want to make the ontological committment to a full-blown ontology. It suffices to align a sub-pattern to the core of PROV-O [15]. The EntityWithProvenance class is any item of interest to which a developer would like to attachprovenance information. That is they are interested in capturing, who or what created that item, what was used to derive it, and what method was used to do so. The “who or what” iscaptured by using the Agent class. The property, wasDerivedFrom is eponymous—it denotes that some set of resources was used during the ProvenanceActivity to generate the EntityWithProvenance.
This pattern is heavily adapted from QUDT1 and [6]. This pattern allows a developer to express a quantity of some stuff. The nature of quantities is rather complex, due to the fact that there are a multitude of dimensions, unit types, and ways to measure quantities. The Quantity class is used to express the nature of the quantity via its QuantityKind. This is intended to be a controlledvocabulary. We direct the reader to QUDT’s documentation for further exploration. A QuantityValue expresses the magnitude of the Quantity via an xsd:double and a Unit. Unit is also recommended to be a controlled vocabulary. 
In OWL, unfortunately, it is not possible to directly represent n-ary relationships. However, it is still possible to capturthat information. This notion is called reification. The Property Reificationpattern is essentially a metapattern; it could be better considered to be a modelling practice. Here, though, we present a set of axioms that will allow a developer to quickly reify a concept by specializing the framework.
The Sequence Pattern is a way of imposing order upon items of interest; it follows the conceptualizationof a Linked List from computer science. This pattern is a simplified view of the Tree Pattern (as found in Section 3.6) and is adapted from [1]. While this pattern seems very abstract, it is both easy to specialize and occurs very frequently. In this resource, the pattern occurs in the Trajectory Pattern (a sequence of Fixes), the SpatiotemporalExtent Pattern (a sequence of Place, Time pairs), and SpatialExtent (a sequence of PointsInSpace.
The SpatialExtent pattern is characterized by a set of Interiors, which are in turn characterizedby a PointInSpace-Sequence.A PointInSpace-Sequence consists of PointInSpace-SequenceElements, which are constituted by PointInSpace.A PointInSpace is described by a value and a reference system. PIS-Sequence is a specialization of the Sequence Pattern (Section  We also further choose to use the Explicit Typing Pattern for PointInSpace and ReferenceSystem.
The SpatiotemporalExtent pattern wraps the Trajectory Pattern (Section 3.10). Essentially, it uses the Trajectory Pattern’s ability to capture discrete snapshots of something moving along some dimension, but casts it into the familiar three physical dimensions, plus time. This is done by adding the atPlace and atTime properties that hang off of Fix. This pattern is more fully described in [13]. The SpatiotemporalExtent is primarily used when it is difficult to separate space and time when talking about a concept. 
Stubs are a very minimal pattern that could also be described as a technique or best practice. Essentially,during modelling, there are frequently times when developers recognize that a concept is complex, but also out of the scope of an ontology or knowledge graph. However, the developerwould like to keep the ontology extensible or allow others to build off of the ontology at that point. One example of this is Name or Title. In many cases, there is no reason to store more than a string for a name or title. However, names and titles are not necessarily inherent to a thing at all times. Yet, delving into those details may be unnecessary for a use-case. To account for this, a developer may want to use as stub.
A TemporalExtent is composed of a number of ComplexTimeIntervals, which may be intervals of non-zero length (i.e. TimeIntervals) or intervals of length 0 (i.e. PointsInSpace). 
The Trajectory Pattern allows a developer to track something moving through some space. This is, of course, very abstract and is intended to be a starting point for capturing any movement that occurs at discrete points in a space. Intuitively, there is the notion of moving through time and space and those captured discrete points in space may be GPS position recordings. This sort of data may be best captured with the SpatiotemporalExtent Pattern (Section 3.7), which extends the Trajectory Pattern. 
The Tree pattern allows a developer to organize data into a tree data structure. An ontological tree, however, is subtly different from those that occur in other parts of computer science; these trees should be viewed as static—something to be queried, not manipulated. For example, a motivating use case is the organization of organisms into a phylogenetic tree.
